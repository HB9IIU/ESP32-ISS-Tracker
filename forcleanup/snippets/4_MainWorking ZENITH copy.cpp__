#include <WiFi.h>
#include <HTTPClient.h>
#include <ArduinoJson.h>
#include <Sgp4.h>
#include <Ticker.h>
#include <NTPClient.h>
#include <WiFiUdp.h>

// Wi-Fi credentials
const char *ssid = "NO WIFI FOR YOU!!!";
const char *password = "Nestle2010Nestle";

// Timezone API key and URL
const String apiKey = "EH7POYI19YHB";
const String apiUrl = "http://api.timezonedb.com/v2.1/get-time-zone?key=" + apiKey +
                      "&format=json&by=position&lat=46.4666463&lng=6.8615008";

// TLE data URL
const char *tleUrl = "https://live.ariss.org/iss.txt";

// NTP Client to get UTC time
WiFiUDP ntpUDP;
NTPClient timeClient(ntpUDP, "pool.ntp.org", 0, 60000); // 0 offset for UTC, update every 60 seconds

Sgp4 sat;
Ticker tkSecond;
unsigned long unixtime;
int timezoneOffset = 0; // Variable to hold timezone offset in seconds

// Observer's location
double observerLat = 46.4666463; // Latitude
double observerLon = 6.8615008;  // Longitude
double observerAlt = 500;        // Altitude

// Time step for pass prediction in seconds
const unsigned long timeStep = 1; // Define the time step here (e.g., 10 seconds)

// Next pass information
unsigned long nextPassStart = 0;
unsigned long nextPassEnd = 0;
double nextPassAOSAzimuth = 0;
double nextPassLOSAzimuth = 0;
double nextPassMaxElevation = 0;
double nextPassPerigee = 0;
unsigned long nextPassCulminationTime = 0; // Time of maximum elevation during the pass

void connectToWiFi()
{
  WiFi.config(INADDR_NONE, INADDR_NONE, INADDR_NONE, IPAddress(8, 8, 8, 8)); // Use Google DNS
  WiFi.begin(ssid, password);
  while (WiFi.status() != WL_CONNECTED)
  {
    delay(500);
    Serial.print(".");
  }
  Serial.println("\nConnected to Wi-Fi.");
}

void getTimezoneOffset()
{
  if (WiFi.status() == WL_CONNECTED)
  {
    HTTPClient http;
    http.begin(apiUrl);
    int httpCode = http.GET();

    if (httpCode == 200)
    {
      String payload = http.getString();
      DynamicJsonDocument doc(512);
      deserializeJson(doc, payload);

      // Extract the gmtOffset and convert to seconds
      timezoneOffset = doc["gmtOffset"];
      Serial.print("Timezone Offset (seconds): ");
      Serial.println(timezoneOffset);
    }
    else
    {
      Serial.println("Failed to retrieve timezone offset.");
    }
    http.end();
  }
}

bool fetchTLE(char *line1, char *line2)
{
  if (WiFi.status() == WL_CONNECTED)
  {
    HTTPClient http;
    http.begin(tleUrl);
    int httpCode = http.GET();

    if (httpCode == 200)
    {
      String payload = http.getString();
      int line1Start = payload.indexOf('\n') + 1;
      int line2Start = payload.indexOf('\n', line1Start) + 1;

      if (line1Start > 0 && line2Start > line1Start)
      {
        payload.substring(line1Start, line1Start + 69).toCharArray(line1, 70);
        payload.substring(line2Start, line2Start + 69).toCharArray(line2, 70);
        http.end();
        return true;
      }
    }
    http.end();
  }
  return false;
}

void updateTime()
{
  timeClient.update();
  unixtime = timeClient.getEpochTime(); // Get the UTC time in seconds since epoch
}

String formatTime(unsigned long epochTime, bool isLocal = false)
{
  time_t t = isLocal ? epochTime + timezoneOffset : epochTime;
  struct tm *tmInfo = gmtime(&t);
  char buffer[25];
  strftime(buffer, 25, "%Y-%m-%d %H:%M:%S", tmInfo);
  return String(buffer) + (isLocal ? " Local" : " UTC");
}

void Second_Tick()
{
  unixtime += 1;
}

// Calculate next visible pass with refined start/end detection and maximum elevation time
void calculateNextPass()
{
  nextPassStart = 0;
  nextPassEnd = 0;
  nextPassMaxElevation = 0;
  nextPassPerigee = 0;
  nextPassCulminationTime = 0; // Reset culmination time
  bool passInProgress = false;

  // Check if the satellite is already above the horizon at the current time
  sat.findsat(unixtime);
  if (sat.satEl > 0) {  // Satellite is already visible
    Serial.println("Satellite currently visible; waiting for it to set before calculating the next pass.");
    // Set initial nextPassStart to now since the pass is ongoing
    nextPassStart = unixtime;
    nextPassAOSAzimuth = sat.satAz;
    passInProgress = true;
  }

  for (unsigned long t = unixtime + timeStep; t < unixtime + 86400; t += timeStep) { // Use the time step variable
    sat.findsat(t); // Calculate satellite position at time `t`

    // If satellite is above the horizon
    if (sat.satEl > 0) {
      if (!passInProgress) {  // New pass starting (AOS)
        passInProgress = true;
        nextPassStart = t;
        nextPassAOSAzimuth = sat.satAz;
        nextPassMaxElevation = sat.satEl;
        nextPassCulminationTime = t; // Initialize culmination time
        nextPassPerigee = sat.satDist;
      } else {  // Pass ongoing
        if (sat.satEl > nextPassMaxElevation) {
          nextPassMaxElevation = sat.satEl;
          nextPassCulminationTime = t; // Update time at maximum elevation
        }
        if (sat.satDist < nextPassPerigee) {
          nextPassPerigee = sat.satDist;
        }
      }
      nextPassEnd = t;                // Update end time with the last time above 0° elevation
      nextPassLOSAzimuth = sat.satAz; // Update LOS azimuth
    } else if (passInProgress) {  // Pass ended (LOS)
      break;
    }
  }

  // Display next pass details if found
  if (nextPassStart != 0 && nextPassEnd != 0) {
    Serial.print("Next pass start time (AOS): ");
    Serial.println(formatTime(nextPassStart));
    Serial.println("Local: " + formatTime(nextPassStart, true));

    Serial.print("AOS Azimuth: ");
    Serial.print(nextPassAOSAzimuth);
    Serial.println("°");

    Serial.print("Maximum elevation during pass: ");
    Serial.print(nextPassMaxElevation);
    Serial.println("°");

    Serial.print("Time of maximum elevation (Culmination): ");
    Serial.println(formatTime(nextPassCulminationTime));
    Serial.println("Local: " + formatTime(nextPassCulminationTime, true));

    Serial.print("Pass duration: ");
    Serial.print((nextPassEnd - nextPassStart) / 60); // Duration in minutes
    Serial.println(" minutes");

    Serial.print("Closest approach (Perigee): ");
    Serial.print(nextPassPerigee);
    Serial.println(" km");

    Serial.print("End of pass (LOS): ");
    Serial.println(formatTime(nextPassEnd));
    Serial.println("Local: " + formatTime(nextPassEnd, true));

    Serial.print("LOS Azimuth: ");
    Serial.print(nextPassLOSAzimuth);
    Serial.println("°");
  } else {
    Serial.println("No visible pass in the next 24 hours.");
  }
}

void setup()
{
  Serial.begin(115200);
  Serial.println();
  Serial.print("Hello");

  // Connect to Wi-Fi
  connectToWiFi();

  // Retrieve the timezone offset
  getTimezoneOffset();

  // Fetch TLE data
  char tle_line1[70];
  char tle_line2[70];
  if (fetchTLE(tle_line1, tle_line2))
  {
    Serial.println("TLE Data Fetched Successfully:");
    Serial.println(tle_line1);
    Serial.println(tle_line2);
  }
  else
  {
    delay(2000);   // Optional: delay to allow Serial message to print
    ESP.restart(); // Restart the ESP32
  }

  // Initialize satellite parameters with fetched TLE data
  char satname[] = "ISS (ZARYA)";
  sat.init(satname, tle_line1, tle_line2);

  // Initialize NTP client and fetch initial time
  timeClient.begin();
  updateTime();

    // Set observer’s location (latitude, longitude, altitude)
  sat.site(observerLat, observerLon, observerAlt);

  // Calculate the next pass
  calculateNextPass();

  delay(30000);
  Serial.println();
  Serial.println("####################################");

  tkSecond.attach(1, Second_Tick); // Call Second_Tick every 1 second
}

void loop()
{
  if (WiFi.status() == WL_CONNECTED)
  {
    updateTime(); // Update time from NTP
  }

  // Live tracking of the satellite
  sat.findsat(unixtime); // Update satellite position based on current unixtime
  
  // Print tracking information
  Serial.println(formatTime(unixtime));
  Serial.print("Azimuth = ");
  Serial.print(sat.satAz, 2);
  Serial.print("°, Elevation = ");
  Serial.print(sat.satEl, 2);
  Serial.print("°, Distance = ");
  Serial.print(sat.satDist, 2);
  Serial.println(" km");

  Serial.print("Latitude = ");
  Serial.print(sat.satLat, 2);
  Serial.print("°, Longitude = ");
  Serial.print(sat.satLon, 2);
  Serial.print("°, Altitude = ");
  Serial.print(sat.satAlt, 2);
  Serial.println(" km");

  // Visibility information
  if (sat.satEl > 0) {
    Serial.println("Visible : Above horizon");
  } else {
    Serial.println("Visible : Under horizon");
  }

  Serial.println(); // Line break for readability
  
  // Periodically calculate the next pass every hour
  static unsigned long lastPassCalc = 0;
  if (unixtime - lastPassCalc > 3600)
  { // Recalculate next pass every hour
    calculateNextPass();
    lastPassCalc = unixtime;
  }

  delay(1000); // Add delay for readability in serial monitor
}
