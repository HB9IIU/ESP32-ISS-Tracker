#include <WiFi.h>
#include <NTPClient.h>
#include <WiFiUdp.h>
#include <TFT_eSPI.h>

// Wi-Fi credentials
const char *ssid = "NO WIFI FOR YOU!!!";
const char *password = "Nestle2010Nestle"; // Corrected password

// TFT setup
TFT_eSPI tft = TFT_eSPI(); // Create TFT object

// NTP setup
WiFiUDP udp;
NTPClient timeClient(udp, "pool.ntp.org", 0, 60000); // Adjust time zone if necessary

// Store previous time to track changes
String previousTime = "";

// Function to display time centered at a given y-position with a specified color
void updateBigClock()
{
    int y = 20;
    int color = TFT_GOLD;
    tft.setTextFont(8);
    tft.setTextSize(1);
    static bool isPositionCalculated = false;
    static int clockXPosition; // Calculated once to center the clock text
    static int clockWidth;     // Width of the time string in pixels
   
        // Perform initial calculation of clock width and position if not already done
        if (!isPositionCalculated)
    {
        String sampleTime = "23:59:59"; // Sample time format for clock width calculation
        clockWidth = tft.textWidth(sampleTime.c_str());
        clockXPosition = (tft.width() - clockWidth) / 2; // Center x position for the clock
        isPositionCalculated = true;                     // Mark as calculated
    }

    // Update the time from NTP
    timeClient.update();

    // Get the current formatted time
    String currentTime = timeClient.getFormattedTime();

    // Only update characters that have changed
    int xPosition = clockXPosition; // Start at the pre-calculated center position
    for (int i = 0; i < currentTime.length(); i++)
    {
        // If character has changed, update it
        if (i >= previousTime.length() || currentTime[i] != previousTime[i])
        {
            // Clear the previous character area by printing a black background
            tft.setCursor(xPosition, y);
            tft.setTextColor(TFT_BLACK, TFT_BLACK); // Black on black to clear
            tft.print(previousTime[i]);

            // Print the new character with the specified color
            tft.setCursor(xPosition, y);
            tft.setTextColor(color, TFT_BLACK); // Color on black background
            tft.print(currentTime[i]);
        }
        // Increment xPosition by width of the current character
        xPosition += tft.textWidth(String(currentTime[i]).c_str());
    }

    // Update previousTime to the new time
    previousTime = currentTime;
}


void displayElevation(int x, int y, float val)
{
    static float prevVal = -1.0;
    static int digitPositions[5]; // Store x-positions of each digit for "359.9" format
    static int decimalPos;
    static bool isInitialized = false;

    // Initialize digit positions, decimal point position, and draw rectangle and label once
    tft.setTextFont(7);
    tft.setTextSize(1);

    if (!isInitialized)
    {
        String sample = "-90.0";
        tft.setTextColor(TFT_BLACK, TFT_BLACK); // Print in black to capture digit positions
        tft.setCursor(x, y);

        // Capture x-coordinates for each character in the sample, with special handling for the decimal point
        for (int i = 0; i < sample.length(); i++)
        {
            digitPositions[i] = tft.getCursorX(); // Capture position for each character
            if (sample[i] == '.')
            {
                decimalPos = digitPositions[i]; // Save the specific position for the decimal point
            }
            tft.print(sample[i]);
        }

        // Define fixed margins
        const int leftMargin = 15;
        const int rightMargin = 15;
        const int topMargin = 8;
        const int bottomMargin = 14;

        // Calculate the width and height of the text field with margins
        int textWidth = tft.textWidth(sample) + leftMargin + rightMargin;
        int textHeight = tft.fontHeight() + topMargin + bottomMargin;

        // Draw the rounded rectangle around the text field
        tft.drawRoundRect(x - leftMargin, y - topMargin, textWidth, textHeight, 8, TFT_DARKGREY);

        // Draw the "Elevation" label centered on the bottom line of the rectangle
        tft.setTextFont(4); // Set font to FONT4 for the label
        String label = "Elevation";
        int labelWidth = tft.textWidth(label);
        int labelX = x - leftMargin + (textWidth - labelWidth) / 2; // Center horizontally
        int labelY = y + textHeight - (tft.fontHeight(4)) / 2 - 3;  // Align to rectangle’s bottom line
        tft.setTextColor(TFT_DARKGREY, TFT_BLACK);
        tft.setCursor(labelX, labelY);
        tft.print(label);

        // Reset font to main display font (FONT7)
        tft.setTextFont(7);

        // Draw the decimal point once at its fixed position
        tft.setTextColor(TFT_GREEN, TFT_BLACK);
        tft.setCursor(decimalPos, y);
        tft.print(".");
        isInitialized = true;
    }

    // Determine the color based on elevation value
    uint16_t color;
    if (val >= -4 && val <= 4)
    {
        color = TFT_DARKYELLOW;
    }
    else if (val < -4)
    {
        color = TFT_DARKRED;
    }
    else
    {
        color = TFT_GREEN;
    }

    // Format val with exactly one decimal place
    char valStr[8];
    sprintf(valStr, "%5.1f", val);
    char prevValStr[8];
    sprintf(prevValStr, "%5.1f", prevVal);

    // Update only digits that have changed, ensuring minus sign changes color too
    for (int i = 0; i < 5; i++)
    {
        if (valStr[i] != prevValStr[i] || (valStr[i] == '-' && color != TFT_RED))
        {
            tft.setCursor(digitPositions[i], y);
            tft.setTextColor(TFT_BLACK, TFT_BLACK);
            tft.print(prevValStr[i]);

            tft.setCursor(digitPositions[i], y);
            tft.setTextColor(color, TFT_BLACK);
            tft.print(valStr[i]);
        }
    }

    // Update decimal point color to match digits
    tft.setCursor(decimalPos, y);
    tft.setTextColor(color, TFT_BLACK);
    tft.print(".");

    // Update prevVal to the current value
    prevVal = val;
}

void displayAzimuth(int x, int y, float val, float elevation)
{
    static float prevVal = -1.0;
    static int digitPositions[5]; // Store x-positions of each digit for "359.9" format
    static int decimalPos;
    static bool isInitialized = false;
    static uint16_t prevColor = TFT_GREEN;

    // Initialize digit positions, decimal point position, and draw rectangle and label once
    tft.setTextFont(7);
    tft.setTextSize(1);
    if (!isInitialized)
    {
        String sample = "359.9";

        tft.setTextColor(TFT_BLACK, TFT_BLACK); // Print in black to capture digit positions
        tft.setCursor(x, y);

        // Capture x-coordinates for each character in the sample, with special handling for the decimal point
        for (int i = 0; i < sample.length(); i++)
        {
            digitPositions[i] = tft.getCursorX(); // Capture position for each character
            if (sample[i] == '.')
            {
                decimalPos = digitPositions[i]; // Save the specific position for the decimal point
            }
            tft.print(sample[i]);
        }

        // Define fixed margins
        const int leftMargin = 15;
        const int rightMargin = 15;
        const int topMargin = 8;
        const int bottomMargin = 14;

        // Calculate the width and height of the text field with margins
        int textWidth = tft.textWidth(sample) + leftMargin + rightMargin;
        int textHeight = tft.fontHeight() + topMargin + bottomMargin;

        // Draw the rounded rectangle around the text field
        tft.drawRoundRect(x - leftMargin, y - topMargin, textWidth, textHeight, 8, TFT_DARKGREY);

        // Draw the "Azimuth" label centered on the bottom line of the rectangle
        tft.setTextFont(4); // Set font to FONT4 for the label
        String label = "Azimuth";
        int labelWidth = tft.textWidth(label);
        int labelX = x - leftMargin + (textWidth - labelWidth) / 2; // Center horizontally
        int labelY = y + textHeight - (tft.fontHeight(4)) / 2 - 3;  // Align to rectangle’s bottom line
        tft.setTextColor(TFT_DARKGREY, TFT_BLACK);
        tft.setCursor(labelX, labelY);
        tft.print(label);

        // Reset font to main display font (FONT7)
        tft.setTextFont(7);

        // Draw the decimal point once at its fixed position
        tft.setTextColor(TFT_GREEN, TFT_BLACK);
        tft.setCursor(decimalPos, y);
        tft.print(".");
        isInitialized = true;
    }

    // Determine the color based on elevation
    uint16_t color = (elevation >= -4 && elevation <= 4) ? TFT_DARKYELLOW : (elevation < 0 ? TFT_DARKRED : TFT_GREEN);

    // Format val with exactly one decimal place
    char valStr[8];
    sprintf(valStr, "%5.1f", val);
    char prevValStr[8];
    sprintf(prevValStr, "%5.1f", prevVal);

    // Update only digits that have changed, or if color has changed
    bool colorChanged = (color != prevColor);
    prevColor = color;

    for (int i = 0; i < 5; i++)
    {
        if (valStr[i] != prevValStr[i] || colorChanged)
        {
            tft.setCursor(digitPositions[i], y);
            tft.setTextColor(TFT_BLACK, TFT_BLACK);
            tft.print(prevValStr[i]);

            tft.setCursor(digitPositions[i], y);
            tft.setTextColor(color, TFT_BLACK);
            tft.print(valStr[i]);
        }
    }

    // Update decimal point color to match digits
    tft.setCursor(decimalPos, y);
    tft.setTextColor(color, TFT_BLACK);
    tft.print(".");

    // Update prevVal to the current value
    prevVal = val;
}



void setup()
{
    // Initialize Serial Monitor for debugging
    Serial.begin(115200);

    // Connect to Wi-Fi
    WiFi.begin(ssid, password);
    while (WiFi.status() != WL_CONNECTED)
    {
        delay(1000);
        Serial.println("Connecting to WiFi...");
    }
    Serial.println("Connected to WiFi");

    // Initialize TFT display
    tft.init();
    tft.setRotation(1); // Adjust rotation if necessary

    // Set font
    tft.setTextSize(1); // Set text size

    // Initialize NTP client
    timeClient.begin();

    // Set background to black initially
    tft.fillScreen(TFT_BLACK);
}

void loop()
{
    static float azimuth = 0.0;
    static float elevation = 0.0;
    // Call updateBigClock with desired y-position and color
    updateBigClock();
    displayElevation(61 - 10, 120, elevation);
    displayAzimuth(277 + 10, 120, azimuth, elevation);
    // Increment azimuth and elevation for testing purposes
    azimuth += 0.3;
    elevation += 0.3;
    if (azimuth > 359.9)
        azimuth = 0.0;
    if (elevation > 90.0)
        elevation = -90.0;
    delay(200); // Update the time every second
}
